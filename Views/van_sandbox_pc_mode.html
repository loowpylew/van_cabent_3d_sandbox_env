<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Van Sandbox — Full (Fixed)</title>
<style>
  :root{--bg:#f6f7f9;--panel:#fff;--muted:#546;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg)}
  .app{display:flex;gap:12px;height:100vh;padding:12px;box-sizing:border-box}
  .left{flex:1;display:flex;flex-direction:column;gap:12px}
  .viewer{flex:1;border-radius:10px;background:#e9eef3;padding:6px;display:flex;flex-direction:column}
  canvas{flex:1;border-radius:8px;background:#e5e7ea}
  .side{width:420px;display:flex;flex-direction:column;gap:12px}
  .panel{background:var(--panel);border-radius:8px;padding:10px;box-shadow:0 6px 18px rgba(0,0,0,0.06);overflow:auto}
  .unit-row{display:flex;gap:10px;align-items:center;padding:8px;border-radius:8px;border:1px solid #f0f3f6}
  .unit-row img{width:80px;height:52px;object-fit:cover;border-radius:6px}
  .zones{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .zone-btn{border:2px dashed #d0d7df;border-radius:8px;padding:8px;text-align:center;background:#fff;cursor:pointer}
  .small{font-size:13px;color:#6b7280}
  .anchor-tweak{display:flex;gap:6px;align-items:center;margin-top:8px}
  input[type="number"]{width:64px}
  footer{font-size:13px;color:#6b7280;text-align:center;padding:8px}
  button{cursor:pointer}
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div class="viewer panel">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
        <div style="flex:1">
          <strong>Van 3D Sandbox — Full (Fixed)</strong>
          <div class="small">Drop .glb or paste direct URL. Trade presets, thumbnails, module placement, export JSON.</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <label class="small">Van:
            <select id="vanSelect">
              <option value="transit">Ford Transit</option>
              <option value="sprinter">Mercedes Sprinter</option>
              <option value="crafter">VW Crafter</option>
              <option value="boxer">Peugeot Boxer</option>
              <option value="master">Renault Master</option>
            </select>
          </label>
          <label class="small">Trade:
            <select id="tradeSelect">
              <option value="">(None)</option>
              <option value="plumber">Plumber</option>
              <option value="electrician">Electrician</option>
              <option value="tiler">Tiler</option>
              <option value="carpenter">Carpenter</option>
            </select>
          </label>
          <button id="resetBtn">Reset</button>
          <button id="exportBtn">Export JSON</button>
        </div>
      </div>

      <div id="dropzone" class="dropzone" style="margin-bottom:8px">
        Drop .glb here or click to select — Current model: <span id="modelName">(none)</span>
        <div style="margin-top:8px">
          <input id="urlLoad" placeholder="Paste direct .glb URL and press Load" style="width:66%"/>
          <button id="loadUrlBtn">Load</button>
        </div>
      </div>

      <canvas id="canvas"></canvas>

      <div style="display:flex;gap:12px;margin-top:8px;align-items:center;flex-wrap:wrap">
        <label class="small"><input id="showFloor" type="checkbox" checked/> Show floor grid</label>
        <label class="small"><input id="vanSeeThrough" type="checkbox" checked/> See-through van</label>

        <div style="flex:1"></div>

        <div class="small">Anchor Nudge (mm)</div>
        <div class="anchor-tweak"><input id="anchorZ" type="number" value="0" step="10"/> <button id="applyAnchor">Apply</button></div>

        <div class="small">Model scale</div>
        <div class="anchor-tweak">
          <input id="scaleVal" type="number" value="1" step="0.001" style="width:90px"/>
          <button id="applyScale">Apply</button>
        </div>
      </div>
    </div>

    <footer>Will attempt to auto-normalize many .glb sources. If a model is malformed, try re-exporting from Blender with Apply Transforms.</footer>
  </div>

  <div class="side">
    <div class="panel">
      <strong>Storage units</strong>
      <div id="unitsContainer" style="margin-top:8px"></div>
    </div>

    <div class="panel">
      <strong>Placement zones</strong>
      <div class="small">Click a unit → choose a zone to place</div>
      <div class="zones" style="margin-top:8px">
        <div class="zone-btn" data-zone="top-left">Top Left</div>
        <div class="zone-btn" data-zone="side-left">Side Left</div>
        <div class="zone-btn" data-zone="bottom-left">Bottom Left</div>
        <div class="zone-btn" data-zone="top-right">Top Right</div>
        <div class="zone-btn" data-zone="side-right">Side Right</div>
        <div class="zone-btn" data-zone="bottom-right">Bottom Right</div>
      </div>
    </div>

    <div class="panel">
      <strong>Sources</strong>
      <div class="small" style="margin-top:6px">
        Use your model download pages (Sketchfab, RigModels, 3DCADBrowser). Convert to .glb if needed and drop here.
      </div>
    </div>
  </div>
</div>

<!-- Three.js r128 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
// ---------- Utilities & visuals ----------
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(canvas.clientWidth, canvas.clientHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xedeff1);

const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth/canvas.clientHeight, 0.01, 5000);

camera.position.set(0,1200,1600);

//const controls = new THREE.OrbitControls(camera, renderer.domElement);
//controls.enableDamping = true; controls.dampingFactor = 0.08; controls.maxPolarAngle = Math.PI/2.1;


const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 250, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.maxPolarAngle = Math.PI;        // allow looking all around
controls.enablePan = true;
controls.screenSpacePanning = false;
controls.minDistance = 0.1;              // allow zooming inside van
controls.maxDistance = 8000;             // reasonable upper bound
controls.update();
controls.target.set(0,250,0); controls.update();


scene.add(new THREE.HemisphereLight(0xffffff, 0xaaaaaa, 0.95));
const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(400,800,300); scene.add(dir);

const VISUAL_SCALE = 0.6;
function mm(v){ return v * VISUAL_SCALE; }

// floor grid
const gridMat = new THREE.LineBasicMaterial({ color:0xcccccc });
function makeGrid(w,h,step){
  const geom = new THREE.BufferGeometry();
  const verts = [];
  for(let x=-w/2;x<=w/2;x+=step){ verts.push(x,0,-h/2, x,0,h/2); }
  for(let z=-h/2;z<=h/2;z+=step){ verts.push(-w/2,0,z, w/2,0,z); }
  geom.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
  return new THREE.LineSegments(geom, gridMat);
}
const floorGroup = new THREE.Group();
const gridMesh = makeGrid(4000*VISUAL_SCALE, 6000*VISUAL_SCALE, 200*VISUAL_SCALE);
floorGroup.add(gridMesh);
scene.add(floorGroup);

// simple wood texture for modules
function makeWoodTexture(){
  const c=document.createElement('canvas'); c.width=512; c.height=512; const ctx=c.getContext('2d');
  ctx.fillStyle='#E6CBA8'; ctx.fillRect(0,0,512,512);
  ctx.strokeStyle='rgba(140,95,50,0.12)';
  for(let y=0;y<512;y+=6){ ctx.beginPath(); ctx.moveTo(0,y+Math.sin(y/8)*2); ctx.quadraticCurveTo(256,y+(Math.random()-0.5)*2,512,y+Math.sin(y/9)*2); ctx.stroke(); }
  return new THREE.CanvasTexture(c);
}
const woodTexture = makeWoodTexture();

// ---------- Presets & modules ----------
const VANS = {
  transit:  { name:'Ford Transit', inner:{w:1700,l:3500,h:1800}, color:0x93a6ff },
  sprinter: { name:'Mercedes Sprinter', inner:{w:1787,l:4410,h:2243}, color:0x9ef08a },
  crafter:  { name:'VW Crafter', inner:{w:1800,l:3400,h:1900}, color:0xf5bf6b },
  boxer:    { name:'Peugeot Boxer', inner:{w:1680,l:3300,h:1750}, color:0x7fb7ff },
  master:   { name:'Renault Master', inner:{w:1700,l:3450,h:1800}, color:0xf4a2d3 }
};

const MODULES = [
  { id:'tool', name:'Tool Chest', type:'toolChest', w:600, d:400, h:400 },
  { id:'draw', name:'Drawer Bank', type:'drawerBank', w:1000, d:450, h:600 },
  { id:'slant', name:'Slanted Shelf', type:'slantedShelf', w:1000, d:320, h:1400 },
  { id:'euro', name:'Euro Bay', type:'euroBay', w:900, d:350, h:800 },
  { id:'tube', name:'Tube Holder', type:'tubeHolder', w:1000, d:300, h:500 },
  { id:'org', name:'Organiser Slim', type:'organiserSlim', w:350, d:220, h:1000 }
];

function svgThumb(text){
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(
    `<svg xmlns="http://www.w3.org/2000/svg" width="240" height="160">
      <rect width="100%" height="100%" fill="#E6CBA8"/>
      <text x="12" y="88" font-size="20" fill="#333">${text}</text>
    </svg>`);
}
MODULES.forEach(m=>m.thumb = svgThumb(m.name));

function makeModuleMesh(meta){
  const w=mm(meta.w), d=mm(meta.d), h=mm(meta.h);
  const mat = new THREE.MeshStandardMaterial({ map:woodTexture, metalness:0.05, roughness:0.75 });
  if(meta.type==='toolChest') return new THREE.Mesh(new THREE.BoxGeometry(w,h,d),mat);
  if(meta.type==='drawerBank'){
    const g=new THREE.Group(); const n=3;
    for(let i=0;i<n;i++){const seg=h/n;const b=new THREE.Mesh(new THREE.BoxGeometry(w,seg-6,d-6),mat);b.position.y=-h/2+(i+0.5)*seg;g.add(b);}return g;}
  if(meta.type==='slantedShelf'){
    const g=new THREE.Group(); const n=Math.max(2,Math.floor(h/mm(300)));
    for(let i=0;i<n;i++){const ty=-h/2+(i+0.5)*(h/n);const dep=d-mm(20)-i*mm(8);const s=new THREE.Mesh(new THREE.BoxGeometry(w,8,dep),mat);
      s.position.set(0,ty,-(d-dep)/2);s.rotation.x=-0.35;g.add(s);}g.add(new THREE.Mesh(new THREE.BoxGeometry(w,16,d),mat));return g;}
  if(meta.type==='euroBay'){
    const g=new THREE.Group(); const bayW=mm(300);const cols=Math.max(1,Math.floor(w/bayW));const colW=w/cols;const rows=Math.max(1,Math.floor(h/mm(200)));
    for(let c=0;c<cols;c++)for(let r=0;r<rows;r++){const bw=colW-mm(10);const bh=h/rows-mm(10);
      const box=new THREE.Mesh(new THREE.BoxGeometry(bw,bh,d-mm(30)),mat);
      box.position.set(-w/2+(c+0.5)*colW,-h/2+(r+0.5)*(h/rows),0);g.add(box);}return g;}
  if(meta.type==='tubeHolder'){
    const g=new THREE.Group();const base=new THREE.Mesh(new THREE.BoxGeometry(w,20,d-20),mat);base.position.y=-h/2+40;g.add(base);
    g.add(new THREE.Mesh(new THREE.BoxGeometry(w,h-80,12),mat));return g;}
  if(meta.type==='organiserSlim'){
    const g=new THREE.Group();const levels=Math.max(3,Math.floor(h/mm(250)));
    for(let i=0;i<levels;i++){const s=new THREE.Mesh(new THREE.BoxGeometry(w,8,d-mm(20)),mat);
      s.position.y=-h/2+(i+0.5)*(h/levels);g.add(s);
      const lip=new THREE.Mesh(new THREE.BoxGeometry(w,20,6),mat);
      lip.position.set(0,s.position.y+6,d/2-6);g.add(lip);}return g;}
  return new THREE.Mesh(new THREE.BoxGeometry(w,h,d),mat);
}

// ---------- UI module list ----------
const unitsContainer=document.getElementById('unitsContainer');
let selectedModule=null;
function buildUnitsUI(){
  unitsContainer.innerHTML='';
  MODULES.forEach(m=>{
    const row=document.createElement('div');row.className='unit-row';
    row.innerHTML=`<img src="${m.thumb}"><div style="flex:1"><div style="font-weight:600">${m.name}</div><div class="small">${m.w}×${m.d}×${m.h}mm</div></div><button>Select</button>`;
    const btn=row.querySelector('button');
    btn.addEventListener('click',()=>{
      selectedModule=m;
      [...unitsContainer.children].forEach(r=>r.style.borderColor='#f0f3f6');
      row.style.borderColor='#a89cff';
    });
    unitsContainer.appendChild(row);
  });
}
buildUnitsUI();

// ---------- GLB loader ----------
const gltfLoader=new THREE.GLTFLoader();
let currentVan=null,interiorBox=null,anchors={},placed=[];

function loadGLB(url,name){
  document.getElementById('modelName').textContent='loading…';
  if(currentVan){scene.remove(currentVan);currentVan=null;}

  gltfLoader.load(url,gltf=>{
    currentVan=gltf.scene;scene.add(currentVan);
    // --- Make van materials transparent for interior visibility ---
    currentVan.traverse((child) => {
    if (child.isMesh) {
        child.material.transparent = true;
        child.material.opacity = 0.25;       // 25% opaque — tweak as desired
        child.material.depthWrite = false;   // helps avoid sorting issues
    }
    });

    currentVan.rotation.set(0,0,0);currentVan.position.set(0,0,0);currentVan.scale.set(1,1,1);

    const box0=new THREE.Box3().setFromObject(currentVan);
    const size0=new THREE.Vector3();box0.getSize(size0);
    if(size0.length()===0||!isFinite(size0.x)){alert('Model appears empty');return;}

    const center0=new THREE.Vector3();box0.getCenter(center0);
    currentVan.position.sub(center0); // centre it
    const targetLength=mm(4200);
    const scale=targetLength/size0.z;
    currentVan.scale.setScalar(scale);

    // Align bottom to grid
    const box1=new THREE.Box3().setFromObject(currentVan);
    const minY=box1.min.y;
    currentVan.position.y -= minY; // lift
    currentVan.position.y += mm(10);

    // new interior box
    const box=new THREE.Box3().setFromObject(currentVan);
    const shrink=mm(40);
    const innerMin=new THREE.Vector3(box.min.x+shrink,0,box.min.z+shrink);
    const innerMax=new THREE.Vector3(box.max.x-shrink,box.max.y-box.min.y-shrink,box.max.z-shrink);
    interiorBox=new THREE.Box3(innerMin,innerMax);

    computeAnchors(innerMin,innerMax);
    updateAnchorMarkers();
    fitCameraToBox(interiorBox);
    document.getElementById('modelName').textContent=name;
  },undefined,err=>{
    alert('GLB load failed');console.error(err);
  });
}

function computeAnchors(min,max){
  anchors={sideLeft:[],sideRight:[]};
  const w=max.x-min.x,l=max.z-min.z;
  anchors['top-left']=new THREE.Vector3(min.x+mm(100),mm(10),min.z+mm(150));
  anchors['top-right']=new THREE.Vector3(max.x-mm(100),mm(10),min.z+mm(150));
  anchors['bottom-left']=new THREE.Vector3(min.x+mm(100),mm(10),max.z-mm(150));
  anchors['bottom-right']=new THREE.Vector3(max.x-mm(100),mm(10),max.z-mm(150));
  const steps=6;
  for(let i=0;i<steps;i++){
    const z=min.z+mm(150)+i*((l-mm(300))/(steps-1));
    anchors.sideLeft.push(new THREE.Vector3(min.x+mm(20),mm(10),z));
    anchors.sideRight.push(new THREE.Vector3(max.x-mm(20),mm(10),z));
  }
}

// ---------- Anchors visual ----------
let anchorMarkers=new THREE.Group();scene.add(anchorMarkers);
function updateAnchorMarkers(){
  scene.remove(anchorMarkers);
  anchorMarkers=new THREE.Group();
  const mat=new THREE.MeshBasicMaterial({color:0x111});
  const cone=new THREE.ConeGeometry(mm(12),mm(28),8);
  for(const k of ['top-left','top-right','bottom-left','bottom-right']){
    if(!anchors[k])continue;const m=new THREE.Mesh(cone,mat);
    m.rotation.x=-Math.PI/2;m.position.copy(anchors[k]);m.position.y+=12;anchorMarkers.add(m);
  }
  (anchors.sideLeft||[]).forEach(p=>{const s=new THREE.Mesh(new THREE.SphereGeometry(mm(6),8,8),mat.clone());s.position.copy(p);s.position.y+=12;anchorMarkers.add(s);});
  (anchors.sideRight||[]).forEach(p=>{const s=new THREE.Mesh(new THREE.SphereGeometry(mm(6),8,8),mat.clone());s.position.copy(p);s.position.y+=12;anchorMarkers.add(s);});
  scene.add(anchorMarkers);
}

// ---------- Placement ----------
function clampPosition(pos,halfW,halfD){
  if(interiorBox){
    pos.x=THREE.Math.clamp(pos.x,interiorBox.min.x+halfW,interiorBox.max.x-halfW);
    pos.z=THREE.Math.clamp(pos.z,interiorBox.min.z+halfD,interiorBox.max.z-halfD);
  }
}
function placeModule(meta,zone){
  const mesh=makeModuleMesh(meta);
  mesh.userData={meta,zone};
  const hw=mm(meta.w)/2,hd=mm(meta.d)/2,h=mm(meta.h);
  let p=new THREE.Vector3(0,h/2+mm(40),0);
  if(anchors[zone])p=anchors[zone].clone();
  if(zone==='side-left'||zone==='side-right'){
    const arr=zone==='side-left'?anchors.sideLeft:anchors.sideRight;
    p=arr[Math.floor(Math.random()*arr.length)].clone();
    if(zone==='side-left'){p.x+=hd;mesh.rotation.y=Math.PI/2;}
    else{p.x-=hd;mesh.rotation.y=-Math.PI/2;}
  }
  p.y=h/2+mm(40);
  clampPosition(p,hw,hd);
  mesh.position.copy(p);
  scene.add(mesh);
  placed.push(mesh);
}

document.querySelectorAll('.zone-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    if(!selectedModule)return alert('Select module first');
    placeModule(selectedModule,btn.dataset.zone);
  });
});

// ---------- Trade presets ----------
function applyTradePreset(k){
  placed.forEach(m=>scene.remove(m));placed.length=0;
  if(!k)return;
  const M=id=>MODULES.find(x=>x.id===id);
  if(k==='plumber'){
    placeModule(M('slant'),'side-left');
    placeModule(M('euro'),'side-left');
    placeModule(M('draw'),'bottom-left');
    placeModule(M('tube'),'bottom-right');
  }
  if(k==='electrician'){
    placeModule(M('org'),'side-right');
    placeModule(M('org'),'side-right');
    placeModule(M('euro'),'side-left');
    placeModule(M('tool'),'top-left');
  }
  if(k==='tiler'){
    placeModule(M('slant'),'side-left');
    placeModule(M('draw'),'bottom-left');
  }
  if(k==='carpenter'){
    anchors.sideLeft.forEach((_,i)=>{if(i%2===0)placeModule(M('tube'),'side-left');});
    placeModule(M('draw'),'bottom-left');
  }
}

// ---------- Controls ----------
document.getElementById('tradeSelect').addEventListener('change',e=>applyTradePreset(e.target.value));

document.getElementById('applyAnchor').addEventListener('click',()=>{
  const off=Number(document.getElementById('anchorZ').value)||0;
  anchors.sideLeft.forEach(p=>p.z+=mm(off));
  anchors.sideRight.forEach(p=>p.z+=mm(off));
  updateAnchorMarkers();
});

document.getElementById('applyScale').addEventListener('click',()=>{
  const s=Math.max(0.0001,Math.min(10,parseFloat(document.getElementById('scaleVal').value)||1));
  if(!currentVan)return alert('No GLB loaded');
  currentVan.scale.set(s,s,s);
  const box=new THREE.Box3().setFromObject(currentVan);
  const shrink=mm(40);
  const innerMin=new THREE.Vector3(box.min.x+shrink,0,box.min.z+shrink);
  const innerMax=new THREE.Vector3(box.max.x-shrink,box.max.y-box.min.y-shrink,box.max.z-shrink);
  interiorBox=new THREE.Box3(innerMin,innerMax);
  computeAnchors(innerMin,innerMax);
  updateAnchorMarkers();
  fitCameraToBox(interiorBox);
});

document.getElementById('vanSeeThrough').addEventListener('change', (e) => {
  const on = e.target.checked;
  if (!currentVan) return;
  currentVan.traverse((child) => {
    if (child.isMesh) {
      child.material.opacity = on ? 0.25 : 1.0;
      child.material.transparent = on;
      child.material.depthWrite = !on;
    }
  });
});

// ---------- Fallback van shell ----------
function createFallbackVan(key){
  if(currentVan){scene.remove(currentVan);currentVan=null;}
  const spec=VANS[key];
  const w=mm(spec.inner.w),l=mm(spec.inner.l),h=mm(spec.inner.h);
  const g=new THREE.Group();
  const shell = new THREE.Mesh(
  new THREE.BoxGeometry(w+mm(40), h+mm(40), l+mm(40)),
  new THREE.MeshStandardMaterial({
    color: spec.color,
    transparent: true,
    opacity: 0.15,           // lighter so you can see inside
    side: THREE.DoubleSide,
    depthWrite: false
  })
);

  shell.position.y=(h+mm(40))/2;g.add(shell);
  scene.add(g);currentVan=g;
  const innerMin=new THREE.Vector3(-w/2,0,-l/2),innerMax=new THREE.Vector3(w/2,h,l/2);
  interiorBox=new THREE.Box3(innerMin,innerMax);
  computeAnchors(innerMin,innerMax);
  updateAnchorMarkers();
  fitCameraToBox(interiorBox);
}

// ---------- Camera fit ----------
function fitCameraToBox(box){
  const size=new THREE.Vector3();box.getSize(size);
  const maxDim=Math.max(size.x,size.y,size.z);
  camera.position.set(0,maxDim*0.9,maxDim*1.2);
  controls.target.set((box.min.x+box.max.x)/2,size.y*0.3,(box.min.z+box.max.z)/2);
  controls.update();
}

// ---------- Event wiring ----------
document.getElementById('vanSelect').addEventListener('change',e=>{
  createFallbackVan(e.target.value);
});
document.getElementById('loadUrlBtn').addEventListener('click',()=>{
  const url=document.getElementById('urlLoad').value.trim();
  if(!url)return alert('Paste a .glb URL');
  loadGLB(url,url.split('/').pop());
});
document.getElementById('resetBtn').addEventListener('click',()=>{
  placed.forEach(m=>scene.remove(m));placed.length=0;
  createFallbackVan(document.getElementById('vanSelect').value);
});
document.getElementById('exportBtn').addEventListener('click',()=>{
  const out=placed.map(m=>{
    const meta=m.userData.meta;
    return {id:meta.id,name:meta.name,zone:m.userData.zone,
      dims_mm:{w:meta.w,d:meta.d,h:meta.h},
      pos_mm:{x:Math.round(m.position.x/VISUAL_SCALE),y:Math.round(m.position.y/VISUAL_SCALE),z:Math.round(m.position.z/VISUAL_SCALE)}};
  });
  const blob=new Blob([JSON.stringify(out,null,2)],{type:'application/json'});
  const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='layout.json';a.click();
});

document.getElementById('showFloor').addEventListener('change',e=>{
  floorGroup.visible=e.target.checked;
});

// drag/drop
const dropzone=document.getElementById('dropzone');
dropzone.addEventListener('dragover',e=>{e.preventDefault();dropzone.style.background='#eef';});
dropzone.addEventListener('dragleave',e=>{dropzone.style.background='';});
dropzone.addEventListener('drop',e=>{
  e.preventDefault();dropzone.style.background='';
  const f=e.dataTransfer.files[0];if(f)loadGLB(URL.createObjectURL(f),f.name);
});
dropzone.addEventListener('click',()=>{
  const inp=document.createElement('input');inp.type='file';inp.accept='.glb';
  inp.onchange=()=>{if(inp.files[0])loadGLB(URL.createObjectURL(inp.files[0]),inp.files[0].name);};
  inp.click();
});

// ---------- Render loop ----------
createFallbackVan('transit');
function animate(){requestAnimationFrame(animate);controls.update();renderer.render(scene,camera);}
// ---------- Camera zoom-to-point & drag-move modules ----------
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let dragInfo = null;

// helper: smoothly tween camera target
function smoothFocus(point) {
  const start = controls.target.clone();
  const end = point.clone();

  // Distance-aware speed (closer = faster)
  const distance = camera.position.distanceTo(point);
  const duration = Math.min(800, Math.max(300, distance * 0.2)); // ms
  const startTime = performance.now();

  function animateFocus(time) {
    const elapsed = time - startTime;
    const t = Math.min(1, elapsed / duration);
    // ease-out cubic
    const ease = 1 - Math.pow(1 - t, 3);
    controls.target.lerpVectors(start, end, ease);
    controls.update();
    if (t < 1) requestAnimationFrame(animateFocus);
  }
  requestAnimationFrame(animateFocus);
}

// pointer down — decide if we’re focusing or dragging
canvas.addEventListener('pointerdown', (event) => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(scene.children, true);

  if (intersects.length > 0) {
    const hit = intersects[0].object;
    // if hit a placed module => begin dragging
    const moduleMesh = placed.find(m => m.id === hit.parent.id || m === hit || m.children.includes(hit));
    if (moduleMesh) {
      const planeNormal = new THREE.Vector3(0, 1, 0); // drag along floor
      const plane = new THREE.Plane(planeNormal, 0);
      const intersection = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersection);
      dragInfo = {
        mesh: moduleMesh,
        offset: intersection.clone().sub(moduleMesh.position),
        plane
      };
      controls.enabled = false;
    } else {
      // clicked on van or empty space — focus camera
      smoothFocus(intersects[0].point);
    }
  }
});

canvas.addEventListener('pointermove', (event) => {
  if (!dragInfo) return;
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersection = new THREE.Vector3();
  if (raycaster.ray.intersectPlane(dragInfo.plane, intersection)) {
    const newPos = intersection.clone().sub(dragInfo.offset);
    dragInfo.mesh.position.x = newPos.x;
    dragInfo.mesh.position.z = newPos.z;
    // keep on floor
    dragInfo.mesh.position.y = mm(dragInfo.mesh.userData.meta.h) / 2 + mm(40);
  }
});

canvas.addEventListener('pointerup', () => {
  if (dragInfo) {
    dragInfo = null;
    controls.enabled = true;
  }
});

animate();
window.addEventListener('resize',()=>{
  renderer.setSize(canvas.clientWidth,canvas.clientHeight);
  camera.aspect=canvas.clientWidth/canvas.clientHeight;camera.updateProjectionMatrix();
});

//true interior inspection, you can  quick toggle to switch from orbit to free camera:
let walkMode = false;
document.addEventListener('keydown', (e) => {
  if (e.key === 'f') {
    walkMode = !walkMode;
    controls.enableRotate = !walkMode;
    document.body.style.cursor = walkMode ? 'crosshair' : 'default';
  }
});

</script>
</body>
</html>
